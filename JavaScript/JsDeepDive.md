# 📍함수정의

함수를 정의하는 방법은 4가지 가 있다.

- 함수 선언문
- 함수 표현식
- function 생정자 함수
- 화살표 함수

## 함수선언문

```jsx
function add (x,y) {
	return x + y;
}
```

함수 리터럴과 유사하지만 **선언문은 함수 이름을 생략할수없고 리터럴은 생략할수있다.**

또 **함수 선언문은 표현식이 아닌 문으로 변수에 할당할수 없다**

하지만 아래코드를 보면 의문점이 생기는데 

```jsx
let add = function add (x,y) {
return x + y ;
}
console.log(add(2,5)); // 7
```

함수 선언문이 변수에 할당되는것처럼 보이는데 이렇게 동작하는 이유는 **자바스크립트 엔진이 코드의 문맥에 따라 함수 리터럴 이나 함수 선언문으로 해석하는 경우가있기때문**인데 간단하게 **함수리터럴을 단독으로 사용하면 함수 선언문 으로 해석**하고 **함수리터럴을 값으로 평가해야되는 문맥이라면 함수 리터럴로 해석**하게된다.

그리고 자바스크립트 엔진은 생성된 함수를 호출하기위해 함수이름과 **동일한 이름의 식별자를 암묵적으로 생성**하고 함수 객체를 할당하게되기때문에 아래와 같은 코드도 호출이 가능하다.

```jsx
function add (x,y) {
	return x + y ;
}
console.log(add(2,5)); // 7
```

따라서 함수는 함수 이름으로 호출하는것이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 를 통해 호출하는것이다.

## 함수 표현식

함수는 객체 타입의 **값의 성질을 가진 일급객체** 이라한다. 일급객체는 함수를 값처럼 자유롭게 사용할수있다는 의미인데 이는 **변수에도 할당할수있다는 얘기다** 

함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는것을 얘기한다.

```jsx
let add = function(x,y) {
	return x+y;
};
console.log(add(2,5)); // 7
```

함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이며 , 함수 객체를 가르키는 식별자를 통해서 호출할수있다.

### 함수 호이스팅

```jsx
// 함수 참조 
console.log(add);
console.log(sub); // undefined

// 함수 호출
console.log(add(2,5)); // 7
console.log(sub(2,5)): // 타입에러 

// 함수 선언문
function add(x,y) {
	return x+y;
};

// 함수 표현식 
var sub = function(x,y) {
	return x+y;
};
```

함수 선언문은 선언문 이전에 호출해도 동작하게되는데 그이유는 **함수 호이스팅**에 있다. 

모든 선언문이 **런타임 이전에 자바스크립트 엔진에 의해 먼저 실행**되는데 함수선언문도 마찬가지로 란타임 이전에 함수 객체가 먼저 생성되고 자바스크립트 엔진은 함수이름과 동일한 식별자를 생성하고 함수객체에 할당한다. 이렇게 함수선언문이 코드의 선두로 끌어올려지는것처럼 동작하는것이 자바스크립트의 고유의 특징인 **함수 호이스팅이라고 한다.**

다만 **함수 호이스팅**과 **변수 호이스팅**에는 미묘한 차이가 존재한다.

먼저 두 호이스팅의 동일한점으로는 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되고 식별자를 생성한다는점에서는 동일하다 하지만 **var 키워드로 선언된 변수는 은 undefined 로 초기화** 되고 **함수선언문 을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.**

따라서 함수 표현식 이전에 함수 참조시 undefined 가 나오는이유는 **변수 호이스팅에 의한 결과**라고 볼수있다.

**함수표현식은 표현식 이후에 참조 또는 호출해야한다.**

## function생성자 함수

자바스크립트에 기본 빌트인 함수 function 의 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 **new 연산자와 호출하면 함수 객체를 생성해서 반환**한다.

```jsx
let add = new Function("x","y","return x+y");

console.log(add(2,5)) // 7
```

이같은 경우는 **클로저를 생성하지않고, 함수선언문이나 표현식으로 생성한 함수와 다르게 동작**하기때문에 일반적이지 않고 바람직하지않다.

## 화살표 함수

ES6 이후 도입된 함수인데 function 키워드 대신 **⇒** 를 사용해 간략한 방법으로 선언할수있다. 

```jsx
const add = (x,y) => x+y;
console.log(add(2,5));  // 7
```

화살표 함수는 **항상** **익명 함수로 정의**한다 

기존함수에서 표현만 간략하게 한것이 아니라 **내부 동작도 간략화**되어있다.

** 추후에 좀더 내용이 보강되어야힘 **
---
# 📍원시값과 객체?

자바스크립트에는 7가지 데이터 타입이 존재하는데 크게 **원시타입** 과 **객체 타입**으로 구분할수있다.

- 원시타입
    - 변경 불가능한 값 즉 읽기 전용 값 이다.
    - 변수에 실제값이 저장된다.
- 객체타입
    - 변경 가능한 값
    - 변수에 참조값이 저장된다.

## 원시값

원시값같은경우는 변경불가능한 값이기때문에 **변수값을 재할당하게되**면 변수는 새로운 메모리 공간을 확보하고 재할당한 값을 저장한뒤 변수가 참조하던 **메모리 공간의 주소를 변경**한다. 이런 값의 특성을 **불변성** 이라고한다.

### 문자

원시값을 저장하려면 먼저 확보해야하는 메모리 크기를 결정해야되는데 원시 값인 문자열은 **1개의 문자는 2바이트**의 메모리 공간을 갖고 몇개의 문자로 이뤄진 문자열인지에 따라 메모리 공간이 결정된다.

자바스크립트의 문자열은 원시 타입이며 변경불가능하다

```jsx
let str = "hi";
str = "hello";
```

위의 코드를보면 str변수에 hi 를 할당한뒤 hello 를 **재할당**했다.

문자열은 원시타입이기때문에 **hi 와 hello 는 메모리에 모두 존재**한다 . str **변수가 가르키는것이 변경**된거다.

문자는 **유사 배열 객체인 형태**를 가지고있다.

**유사배열**이란 마치 **배열처럼 인덱스로 프로퍼티 값에 접근**할수있고 **length 프로퍼티를 갖는 객체**를 말한다.

다만 문자열은 원시 값이므로 에러는 나지않지만 **변경**할수없다 

여기서 **변경** 과 **재할당** 을 잘 구별해야한다.

```jsx
let str = "abc";
str[0] = "A";
// 해당 문자열을 변경하는것은 불가능하다.
console.log(str); // abc

str = "dce"
// 변수 값을 재할당 하는것은 가능하다.
console.log(str) // dce
```

### 값에 의한 전달

변수에 원시값을 갖는 변수를 할당하게되면 **할당받는 변수** 에는 **할당되는 변수** 의 **원시값이 복사되어 전달**된다. 

이같은 경우를 값에 의한 전달 이라고 한다. 

이둘은 같은 메모리에 저장된 값을 바라보는것이 아닌 **복사된 별개의 값을 갖게**되는것이다.

## 객체

**객체는 프로퍼티 개수가 정해져있지않고 동적으로 추가되고 삭제 할수있다.** 

프로퍼티 값에 제약도없어 **메모리 공간의 크기를 사전에 정해 둘수 없다.**

### 변경 가능한 값

원시값은 변경 불가능한 값이므로 원시 값을 가진 변수는 재할당 외에는 방법이 없다.

다만 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할수있고 동적으로 추가 , 프로퍼티 값을 갱신할수도 삭제할수도있다. 

```jsx
let person ={
	name : "jaehyun"
};
// 변수에 객체를 할당 

person.name = "kim";
// 프로퍼티 값 갱신 
Person.address = "Seoul";
// 프로퍼티 동적 생성

```

결국에 **원시값을 갖는 변수의 값을 변경하려면 재할당을통해 메모리에 새로 생성**해야한다.

**객체는 재할당하지않고 변경 가능하기에 변수의 참조 값은 변경되지않는다** .

### 참조에 의한 전달

객체를 가르키는 **참조값이 복사되어 전달되는것을 의미**하는데  person 과 copy 의 변수 메모리 주소는 다르지만 **모두 동일한 객체를 가르킨다 .** 이것을 **두개의 식별자가 하나의 객체를 공유한다** 라고한다.

여기서 **어느 한쪽의 객체를 변경하면 서로 영향을 주고받는다.**

```jsx
let person ={
	name : "jaehyun"
};
let copy = person;
// 참조값을 복사 
```

# 📍객체 리터럴

**자바스크립트는 객체 기반형 프로그래밍 언어**이다.

**`객체`** 는 0개 이상의 **프로퍼티와 메서드로 구성된 집합** 이며 

**`프로퍼티`** 는 **객체의 상태를 나타내는 값** 이라 하고 **키와 값**으로 구성된다.

### 객체 리터럴에 의한 객체 생성

**c++**이나 **자바** 같은 `클래스 기반 객체 지향 언어`는 **클래스를 사전에 정의**하고 **new 연산자**와 함께 생성자를 호출해서 **인스턴스를 생성**하는 방식으로 객체를 생성하지만,

**자바스크립트**는 `프로토타입 기반 객체지향 언어`이기때문에 **다양한 객체 생성 방법을 지원**한다.

- 객체 리터럴
    
    **자바스크립트**에서는 **일반적으로는 객체 리터럴**을 사용해서 객체를 생성하게된다.
    
    객체 리터럴은 **중괄호({...}) 사용해 객체 생성**을 한다.
    
    ```jsx
    // 객체 리터럴을 사용해서 객체 생성 
    let person = {
    	name: 'jaehyun',
    	sayHello : function() {
    		console.log(`hello my name is ${this.name}.`);	
    	}
    };
    // 중괄호 안에 프로퍼티를 정의하지않으면 빈객체가 생성된다.
    ```
    
    이러한 방식은 **객체 리터럴에 프로퍼티를 포함**시켜 **객체를 생성함과 동시에 프로퍼티를 만들수있다**
    
    또 생성한 이후에 **프로퍼티를 동적으로 추가**도 할수있다.
    
    ### ES6 이후 추가된 객체 리터럴 확장기능 추가
    
    - 프로퍼티 값은 **변수에 할당된 값**을 넣을수있다.
    - 프로퍼티 값에 변수를 사용하는경우 **키와 이름이 동일**하다면 **프로퍼티 키를 생략할수있다**. 이때 키이름은 **변수 이름으로 자동 생성**된다.
    - **계산된 프로퍼티 이름**
        - 문자열, 문자열로 타입변환할수있는 값으로 평가되는 표현식을 사용해 키를 **동적으로 생성할수있다.**
        
        ```jsx
        const prefix = "prop" ;
        let i =0;
        
        // 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 키를 동적으로 생성
        const obj ={
        	[`${prefix}-${++i}`] : i ,
        	[`${prefix}-${++i}`] : i ,
        	[`${prefix}-${++i}`] : i ,
        };
        ```
        
    
- object 생성자 함수
- 생성자 함수
- object.create 메서드
- 클래스 (ES6)

### 프로퍼티

- `프로퍼티 키` : 빈 문자열을 포함한 **모든 문자열 , 심벌 값**
    - **프로퍼티 값**에 접근할수있는 **식별자 역할**
    - **식별자 네이밍 규칙에 준수**하다면 **따옴표를 생략 가능**하다
    - **식별자 네이밍 규칙에 따르지않는 이름**에는 반드시 **따옴표 를 사용**해야한다.
    - 이미존재하는 프로퍼티 키를 **중복선언하면** 나중에 선언된 값이 **덮어쓰게된다**.
- `프로퍼티 값` : 자바스크립트에서 사용할수있는 **모든 값**
    - 이미 **존재**하는 프로퍼티에 값을 할당하면 값이 **갱신**된다.
    - 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되고 추가된다.
    
    ```jsx
    let person = { name : "jaehyun", };
    
    person.age = 20;
    
    console.log(person); // {name:"jaehyun", age:20}
    ```
    

### 프로퍼티 접근

프로퍼티에 접근하는 방법은 **2가지**가 있다.

프로퍼티 키가 **식별자 네이밍 규칙**을 준수하는 이름이라면 **2가지 다 사용가능**하다.

그게아니라면 반드시 **대괄호 표기법을 사용**해야한다.

- `마침표 표기법`
- `대괄호 표기법`
    - **프로퍼티 키** 는 **따옴표로 감싼 문자열** 이여야 한다.
    - 아니면 **레퍼랜스 에러**가 발생한다.

```jsx
let person = {
	name : "jaehyun",
};

console.log(person.name);
//마침표 표기법 
console.log(person["name"]);
//대괄호 표기법
console.log(person.age);
//존재하지 않은 프로퍼티에 접근하면 undefined 을 반환한다.
```

- `프로퍼티 삭제`
    - 존재하는 프로퍼티를 delete 연산자 사용해서 객체의 프로퍼티를 삭제 할수있다.
    - `delete 객체.프로퍼티키 ;`

### 메서드

**프로퍼티 값이 함수일경우** 일반함수와 구별하기위해 **메서드** 라 부른다.

즉 **메서드**는 **객체에 묶여있는 함수**를 의미한다.
