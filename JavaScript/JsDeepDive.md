# 📍15장 let, const 키워드와 블록 레벨 스코프

## var 변수의 문제점

### 변수 중복 선언 허용

var 키워드로 선언한 변수는 **중복 선언이 가능하다**

```jsx
var x = 1;
var y = 1;
// 같은 스코프 내에 중복 선언을 허용한다.
// 초기화문이 있는 변수선언문은 var 키워드가 없는 것처럼 동작한다.

var x = 100;
// 초기화 문이 없는 변수 선언문은 무시된다.
var y;
console.log(x); // 100
console.log(y); //1
```

### 함수 레벨 스코프

var 키워드로 선언한 변수는 **함수의 코드 블록만을 지역스코프로 인정**하는데

외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 **전역 변수처리**가 된다.

```jsx
var x = 1;
if (true) {
  // x는 전역 변수이다. 이미선언된 x 가 있으므로 중복선언된다.
  var x = 10;
}
console.log(x); // 10

var i = 10;
// for 문에서 선언한 i 는 전역변수이다. 이미선언한 변수가있으므로 중복선언된다.
for (var i = 0; i < 5; i++) {
  console.loe(i);
}
console.log(i); // 5
```

### 변수 호이스팅

var 키워드로 변수를 선언하면 변수 호이스팅이 발생되는데 변수 선언문 이전에 참조할수있다 다만 할당이전이라면 undefined 를 반환한다.

```jsx
console.log(foo); // undefined
foo = 123; // 변수 에 값 할당
console.log(foo); // 123
var foo; // 변수 선언은 런타임이전에 자바스크립트엔진에의해 암묵적으로 실행된다.
```

## let 키워드

ES6 이후로 var 키워드의 단점을 보안하기위해 만들어졌다.

### 변수 중복 선언 금지

var 키워드와 다른점으로는 var 는 변수 중복 선언이 가능하지만 **let 키워드는 중복선언이 불가능**하다.

중복선언시 **문법 에러가 발생**한다 ( systaxError )

### 블록 레벨 스코프

let 키워드는 **모드 코드 블록 ( 함수 , if , for , while , try/catch 등 ) 을 지역 스코프로 인정하는 블록 레벨 스코프**를 가지고있다.

### 변수 호이스팅

`var 키워드`는 런타임 이전에 자바스크립트 엔진에서 암묵적으로 **선언과 초기화 단계가 한번에 진행**되는데

`let 키워드`로 선언한 **변수는 선언단계와 초기화 단계가 분리되서 진행**된다.

런타임 이전에 자바스크립트 엔진으로 인해 암묵적으로 **선언단계가 먼저 실행되긴 하나** , **초기화 단계는 변수 선언문에 도달했을때 실행이된다**. **초기화 단계 이전에 참조하려하면 참조에러 ( ReferenceError ) 가 발생**한다. let 키워드 선언단계 부터 초기화 단계 전까지 변수를 참조할수없는 구간을 를 **일시적 사각지대** 라고 한다.

결국 var 와 let 모두 변수 호이스팅이 발생하지만 var 는 선언과 초기화 단계가 같이 진행되고

let 은 선언만된상태에서 변수선언문에 코드진행순서가 오면 그때 초기화 진행을 하는 차이점이있어

**변수 호이스팅이 발생 하지않는 것처럼 동작**하게된다.

### 전역 객체와 let

var 키워드로 선언한 전역변수와 , 함수 들은 모두 전역객체 window의 프로퍼티가 된다.

```jsx
var x = 1;
y = 2;
function foo() {}

console.log(window.x); // 1
console.log(window.y); // 2
console.log(window.foo); // foo() {}
console.log(x); // 1
console.log(y); // 2
console.log(foo); // foo() {}

// 전역변수로 선언한 let 은 전역객체의 프로퍼티가 아니다
let x = 1;
console.log(window.x); // undefined
console.log(x); // 1
```

다만 let 키워드로 선언한 전역 변수는 전역객체의 프로퍼티가 아니기때문에 window. 으로 접근이 불가능하다. let 의 전역 변수는 보이지 않는 개념적인 블록 내에서 존재하기때문이다

## const 키워드

const 키워드는 **상수를 선언하기위해서 사용**한다.

### 선언과 초기화

const 키워드로 선언한 변수는 반드시 **선언과 동시에 초기화 해야한다.**

const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 **블록레벨스코프를 가지며** 변**수 호이스팅이 발생하지 않는 것 처럼 동작**한다.

### 재할당 금지

상수 이기때문에 var 와 let 과 같이 **재할당이 금지되있다.** ( typeError )

### 상수

const 키워드로 선언된 변수에 원시 값을 할당할 경우 **원시 값은 변경할수없는 값** 이고 c**onst 키워드에 의해 재할당이 금지**되므로 **할당된 값을 변경할수있는 방법은 없다.**

일반적으로 **상수의 이름은 대문자로 선언해 상수임을 명확히 표현**하고 **여러단어일 경우는 \_ 를 사용**해서 구분하는게 일반적이다.

### const 키워드와 객체

const 키워드로 선언된 변수에 원시값은 변경불가능하지만 const 키워드로 선언된 변수에 객체 값은 변경이 가능하다.

**const 의 키워드는 재할당을 금지할뿐 “ 불변 “ 을 의미하지는 않는다.**

**변수 선언에는 기본적으로 const 를 사용**하고 **let 은 재할당이 필요한 경우 한정에서 사용**하는것이좋다.

**ES6 이후로는 var 는 사용하지않는다**

# 📍14장 전역 변수의 문제점

### 전역변수

전역변수를 선언한 의도는 **코드 어디서든 참조하고 할당할수있는 변수로 사용하겠다는 의미**인데 이는 모든코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는것이다. 즉 **해당 코드가 끝날때까지 생명주기가 이어진다.**

또한 스코프 체인상 가장 종점에 위치해있기때문에 검색속도가 가장 느리다. (물론 차이는 그렇게 크진않다)

## 전역변수의 사용을 억제하는방법

### 즉시 실행 함수

함수 정의와 동시에 호출되는 **즉시실행함수는 한번만 호출된**다. 이런특성을 이용해 **전역변수의 사용을 제한하는 방법**이다.

```jsx
(function () {
  var foo = 10;
  // 즉시 실행 함수의 지역 변수 스코프
})();
```

### 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고싶은 변수를 프로퍼티로 추가한다.

```jsx
ver MYAPP = {} // 전역 스페이스 객체

MYAPP.person = {
  name: "Lee",
  address: "Seoul",
};
// 네임 스페이스 객체에 또 객체를 프로퍼티로
// 추가해서 계층적으로 구성할수도있다
console.log(MYAPP.person.name); // lee
```

### 모듈패턴

모듈패턴은 클래스를 모방해서 관련된변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈을 만드는것인데 자바스크립트의 강력한 기능인 클로저 기능을 동반한다.

해당 모듈화의 특징으로는 캡슐화 까지 구현할수있다.

**캡슐화** 는 객체의 **특정 프로퍼티와 메서드를 감출목적으로 하나로 묶는것을말하며 해당 프로퍼티와 메서드를 감출목적으로 사용하기도한다 . 이를 정보 은닉이라 한다.**

대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는데 public, private, protected 등 접근 제한자를 두어 공개범위를 한정할수있는데 자바스크립트는 해당 접근 제한자 를 제공하지않아 모듈패턴을 통해 한정적이지만 정보은닉을 구현하기 위해사용한다.

```jsx
var Counter = function () {
  var num = 0;

  return {
    incresase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
};
// private 변수는 외부로노출이 되지않음
console.log(Counter.num); // undefined

console.log(Counter.incresase()); // 1
console.log(Counter.incresase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0

// 모듈화한 메소드를 통해서 Counter 안에 변수를 조작할수있다.
```

### ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하는데 해당 모듈파일에서는 **var 키워드로 선언한 변수는 더이상 전역변수가 아니며 window 객체 프로퍼티도 아니다.**

```jsx
<script type="module" src="lib.mjs"></script>
```

확장자는 mjs 를 권장하고 스크립트 타입에 module 어리티뷰트를 추가하면 해당 파일은 모듈로써 동작하게된다.

# 📍13장 스코프

# 스코프

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할수이쓴ㄴ 유효 범위가 결정되는데 이를 스코프 라고 한다.

## 스코프의 종류

- 전역 스코프
- 지역스코프

### 전역스코프

전역스코프는 코드의 **가장 바깥 영역**을 말한다. 전역에 변수를 선언하면 전연스코프를 갖는 **전역변수가 되는데 전역 변수는 어디든지 참조 가 가능하다.**

### 지역스코프

지역은 **함수 몸체 내부**를 말하는데 지역에서 변수를 선언하면 해당 변수는 지역스코프를 갖게된다. 즉 **함수내부에서만 참조**할수있다.

### 스코프 체인

중첩함수에서 **스코프는 계층적으로 존재**하게되는데 전역 > 함수 > 중첩함수 스코프 가 계층적으로 연결된것을 스코프 체인이라고한다.

변수를 참조할때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하여 선언된 변수를 검색한다. 이를통해 상위 스코프에서 생성한 변수를 하위 스코프에서도 참조할수있다. 즉 전역 스코프 변수를 중첩스코프 내부에서 사용할수있는 동작원리가 이때문이다.

다만 거꾸로 **중첩함수내부에서 상위단계 스코프에서는 참조가 불가능하다**

### 함수레벨 스코프

var 키워드로 선언된 변수는 오로지 함수의 코드블록 만을 지역스코프로 인정한다. 이러한 특성을 함수레벨 스코프라 한다.

```jsx
var x = 10;
if (true) {
  var x = 1;
}

console.log(x); // 1

var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 0 1 2 3 4 5
```

C 나 java 등 대부분의 다른언어는 함수 몸체 뿐만아리나 모든 코드블록 if , for , while , try/catch 등 지역스코프를 만드는데 var 에서는 오로지 **함수 만 지역스코프를 인정**하기때문에 의도치않게 위 코드와 같이 값이 변경될수있다.

### 렉시컬 스코프

두가지 패턴을 예측할수있다.

1. **함수를 어디서 호출했는지** 따라 함수 상위 스코프를 결정한다
2. **함수를 어디서 정의 했는지**에 따라 함수 상위 스코프를 결정한다.

프로그래밍은 이 두가지 패턴중 한가지 방식으로 함수 의 상위 스코프를 결정한다.

첫번째 방식은 동적 스코프 라고 하는데 함수를 정의하는 시점에서 함수가 어디서 호출될지 알수없어 함수가 **호출되는 시점에 동적으로 상위 스코프를 결정하기에 동적스코프라 한다**.

두번째는 **렉시컬스코프** 또는 **정적스코프라고** 부른다 동적 스코프처럼 상위 스코프가 동적으로 변하지 않고 **함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기때문에 정적 스코프라 한다 .**

**자바스크립트 를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다**

자바스크립으는 **렉시컬 스코프**를 따르므로 함수를 어디서 호출했는지가 아니라 **함수를 어디서 정의했는지에따라 상위 스코프를 결정**한다.

```jsx
var x = 1;
function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

---

# **📍12장 함수 -2**

## 참조의 의한 전달과 외부 상태의 변경

**원시값**은 **값에 의한 전달** 이고 **객체**는 **참조에 의한 전달방식**으로 동작한다.

**매개변수또한 타입에따라 동일하게 동작**하기때문에 **매개변수에 원시값을 전달받을때는 값자체가 복사**되어 전달되어 함수내부에서 변경을해도 외부원시값을 가지고있는 변수에는 아무런 영향이 없다. 다만 **객체를 전달받을때는 참조 값이 전달되기때문에 해당 함수에서 변경하면 외부 객체에도 영향**이 간다.

```jsx
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "kim";
}

//외부 값
let num = 100;
let person = { name: "Lee" };

console.log(num); // 100
console.log(person); // name : "Lee"
// 원시값은 값 자체가 복사되고 , 객체는 참조값이 복사되어 매개변수로 전달된다.
changeVal(num, person);

//원시값은 원본이 훼손되지않고
console.log(num); // 100
// 객체는 원본이 훼손된다.
console.log(person); // name : "kim"
```

이렇게 외부객체를 변경시키는것은 **상태변화에 추적에 어렵고 코드의 복잡성을 증가시키고 가독성을 해치는 원인**이된다. 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든이들에게 변경사실을 통지하고 대처하는 추가대응이 필요하다.

이런 문제해결 방법중 하나로 객체를 **불변 객체**로 만들어서 사용하는것인데

**불변객체는 객체를 마치 원시값처럼 변경 불가능한 값으로 동작하게 만드는것이다**.

## 다양한 함수의 형태

### 즉시 실행 함수

**함수의 정의와 동시에 즉시 호출되는 함수이다**. 이 함수는 한번 호출되면 다시 호출할수없으며

일반적으로 익명 함수를 사용하고 즉시 실행 함수는 **반드시** **그룹연산자 (...) 로 감싸야한다.**

```jsx
let res = (function (a, b) {
  return a * b;
})(3, 5);
console.log(res); // 15

// 일반 함수처럼 값을 반환할수도 인수를 전달할수도있다.
```

### 재귀 함수

함수가 자기자신을 호출하는것을 재귀호출이라하고 , **재귀호출을 수행하는 함수를 재귀함수**라한다.

재귀함수는 반복되는 처리를 위해 사용한다.

```jsx
// 10 부터 0 까지 출력하는 함수
function coundown(n) {
  if (n < 0) return;
  console.log(n);
  coundown(n - 1); // 재귀호출
}
coundown(10);
```

**for 반복문 대신 간단히 재귀함수를 통해서 구현**할수있다.

함수내부에서 재귀 함수를 호출할때 함수 이름, 식별자 를 통해서 할수있다

다만 **함수 외부에서 호출시에는 식별자를 통해서 호출**해야한다.

### 중첩 함수

**함수 내부에 정의된 함수를 중첩 함수**라고한다. 중첩함수는 외부 함수 내부에서만 호출이 가능하고 외부함수의 변수를 참조할수있다.

```jsx
function outer() {
  // 외부함수
  let x = 1;
  function inner() {
    // 중첩함수
    let y = 2;
    // 외부함수의 변수 참조 가능
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

### 콜백 함수

**함수의 매개변수를 통해** **다른 함수의 내부로 전달되는함수를 콜백함수** 라고 한다.

또한 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차 함수라고 한다.

```jsx
function repeat(n, **f)** {
    for (let i = 0; i < n; i++){
        f(i); // i를 전달하면서 f 호출
    }
}

let logAll = function (i) {
    console.log(i);
};
// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

let logOdds = function (i) {
    if (i % 2) console.log(i);
};

repeat(5, logOdds); // 1 3
```

### 순수 함수와 비순수 함수

**어떤 외부 상태에 의존하지 않고 변경하지도않는 순수 함수**와 **외부상태에 의존하거나 외부상태를 변경하는 비 순수 함수**가 있다.

```jsx
var count = 0;

// 인자를 받지않고 외부상태를 직접 참조
function increase() {
  return ++count;
}
```

## 비순수함수 는 **인수를 전달받지않고 함수 내부에서 외부상태를 직접 참조**하여 외부상태에 의존하여 반환값이 변할수있고 외부상태도 변할수있기때문에 코드 복잡성과 상태변화의 추적이 어려워져 권장되지않는다

# 📍함수정의

함수를 정의하는 방법은 4가지 가 있다.

- 함수 선언문
- 함수 표현식
- function 생정자 함수
- 화살표 함수

## 함수선언문

```jsx
function add(x, y) {
  return x + y;
}
```

함수 리터럴과 유사하지만 **선언문은 함수 이름을 생략할수없고 리터럴은 생략할수있다.**

또 **함수 선언문은 표현식이 아닌 문으로 변수에 할당할수 없다**

하지만 아래코드를 보면 의문점이 생기는데

```jsx
let add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5)); // 7
```

함수 선언문이 변수에 할당되는것처럼 보이는데 이렇게 동작하는 이유는 **자바스크립트 엔진이 코드의 문맥에 따라 함수 리터럴 이나 함수 선언문으로 해석하는 경우가있기때문**인데 간단하게 **함수리터럴을 단독으로 사용하면 함수 선언문 으로 해석**하고 **함수리터럴을 값으로 평가해야되는 문맥이라면 함수 리터럴로 해석**하게된다.

그리고 자바스크립트 엔진은 생성된 함수를 호출하기위해 함수이름과 **동일한 이름의 식별자를 암묵적으로 생성**하고 함수 객체를 할당하게되기때문에 아래와 같은 코드도 호출이 가능하다.

```jsx
function add(x, y) {
  return x + y;
}
console.log(add(2, 5)); // 7
```

따라서 함수는 함수 이름으로 호출하는것이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 를 통해 호출하는것이다.

## 함수 표현식

함수는 객체 타입의 **값의 성질을 가진 일급객체** 이라한다. 일급객체는 함수를 값처럼 자유롭게 사용할수있다는 의미인데 이는 **변수에도 할당할수있다는 얘기다**

함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는것을 얘기한다.

```jsx
let add = function (x, y) {
  return x + y;
};
console.log(add(2, 5)); // 7
```

함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이며 , 함수 객체를 가르키는 식별자를 통해서 호출할수있다.

### 함수 호이스팅

```jsx
// 함수 참조
console.log(add);
console.log(sub); // undefined

// 함수 호출
console.log(add(2,5)); // 7
console.log(sub(2,5)): // 타입에러

// 함수 선언문
function add(x,y) {
	return x+y;
};

// 함수 표현식
var sub = function(x,y) {
	return x+y;
};
```

함수 선언문은 선언문 이전에 호출해도 동작하게되는데 그이유는 **함수 호이스팅**에 있다.

모든 선언문이 **런타임 이전에 자바스크립트 엔진에 의해 먼저 실행**되는데 함수선언문도 마찬가지로 란타임 이전에 함수 객체가 먼저 생성되고 자바스크립트 엔진은 함수이름과 동일한 식별자를 생성하고 함수객체에 할당한다. 이렇게 함수선언문이 코드의 선두로 끌어올려지는것처럼 동작하는것이 자바스크립트의 고유의 특징인 **함수 호이스팅이라고 한다.**

다만 **함수 호이스팅**과 **변수 호이스팅**에는 미묘한 차이가 존재한다.

먼저 두 호이스팅의 동일한점으로는 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되고 식별자를 생성한다는점에서는 동일하다 하지만 **var 키워드로 선언된 변수는 은 undefined 로 초기화** 되고 **함수선언문 을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.**

따라서 함수 표현식 이전에 함수 참조시 undefined 가 나오는이유는 **변수 호이스팅에 의한 결과**라고 볼수있다.

**함수표현식은 표현식 이후에 참조 또는 호출해야한다.**

## function생성자 함수

자바스크립트에 기본 빌트인 함수 function 의 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 **new 연산자와 호출하면 함수 객체를 생성해서 반환**한다.

```jsx
let add = new Function("x", "y", "return x+y");

console.log(add(2, 5)); // 7
```

이같은 경우는 **클로저를 생성하지않고, 함수선언문이나 표현식으로 생성한 함수와 다르게 동작**하기때문에 일반적이지 않고 바람직하지않다.

## 화살표 함수

ES6 이후 도입된 함수인데 function 키워드 대신 **⇒** 를 사용해 간략한 방법으로 선언할수있다.

```jsx
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

화살표 함수는 **항상** **익명 함수로 정의**한다

기존함수에서 표현만 간략하게 한것이 아니라 **내부 동작도 간략화**되어있다.

## ** 추후에 좀더 내용이 보강되어야힘 **

# 📍원시값과 객체?

자바스크립트에는 7가지 데이터 타입이 존재하는데 크게 **원시타입** 과 **객체 타입**으로 구분할수있다.

- 원시타입
  - 변경 불가능한 값 즉 읽기 전용 값 이다.
  - 변수에 실제값이 저장된다.
- 객체타입
  - 변경 가능한 값
  - 변수에 참조값이 저장된다.

## 원시값

원시값같은경우는 변경불가능한 값이기때문에 **변수값을 재할당하게되**면 변수는 새로운 메모리 공간을 확보하고 재할당한 값을 저장한뒤 변수가 참조하던 **메모리 공간의 주소를 변경**한다. 이런 값의 특성을 **불변성** 이라고한다.

### 문자

원시값을 저장하려면 먼저 확보해야하는 메모리 크기를 결정해야되는데 원시 값인 문자열은 **1개의 문자는 2바이트**의 메모리 공간을 갖고 몇개의 문자로 이뤄진 문자열인지에 따라 메모리 공간이 결정된다.

자바스크립트의 문자열은 원시 타입이며 변경불가능하다

```jsx
let str = "hi";
str = "hello";
```

위의 코드를보면 str변수에 hi 를 할당한뒤 hello 를 **재할당**했다.

문자열은 원시타입이기때문에 **hi 와 hello 는 메모리에 모두 존재**한다 . str **변수가 가르키는것이 변경**된거다.

문자는 **유사 배열 객체인 형태**를 가지고있다.

**유사배열**이란 마치 **배열처럼 인덱스로 프로퍼티 값에 접근**할수있고 **length 프로퍼티를 갖는 객체**를 말한다.

다만 문자열은 원시 값이므로 에러는 나지않지만 **변경**할수없다

여기서 **변경** 과 **재할당** 을 잘 구별해야한다.

```jsx
let str = "abc";
str[0] = "A";
// 해당 문자열을 변경하는것은 불가능하다.
console.log(str); // abc

str = "dce";
// 변수 값을 재할당 하는것은 가능하다.
console.log(str); // dce
```

### 값에 의한 전달

변수에 원시값을 갖는 변수를 할당하게되면 **할당받는 변수** 에는 **할당되는 변수** 의 **원시값이 복사되어 전달**된다.

이같은 경우를 값에 의한 전달 이라고 한다.

이둘은 같은 메모리에 저장된 값을 바라보는것이 아닌 **복사된 별개의 값을 갖게**되는것이다.

## 객체

**객체는 프로퍼티 개수가 정해져있지않고 동적으로 추가되고 삭제 할수있다.**

프로퍼티 값에 제약도없어 **메모리 공간의 크기를 사전에 정해 둘수 없다.**

### 변경 가능한 값

원시값은 변경 불가능한 값이므로 원시 값을 가진 변수는 재할당 외에는 방법이 없다.

다만 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할수있고 동적으로 추가 , 프로퍼티 값을 갱신할수도 삭제할수도있다.

```jsx
let person = {
  name: "jaehyun",
};
// 변수에 객체를 할당

person.name = "kim";
// 프로퍼티 값 갱신
Person.address = "Seoul";
// 프로퍼티 동적 생성
```

결국에 **원시값을 갖는 변수의 값을 변경하려면 재할당을통해 메모리에 새로 생성**해야한다.

**객체는 재할당하지않고 변경 가능하기에 변수의 참조 값은 변경되지않는다** .

### 참조에 의한 전달

객체를 가르키는 **참조값이 복사되어 전달되는것을 의미**하는데 person 과 copy 의 변수 메모리 주소는 다르지만 **모두 동일한 객체를 가르킨다 .** 이것을 **두개의 식별자가 하나의 객체를 공유한다** 라고한다.

여기서 **어느 한쪽의 객체를 변경하면 서로 영향을 주고받는다.**

```jsx
let person = {
  name: "jaehyun",
};
let copy = person;
// 참조값을 복사
```

# 📍객체 리터럴

**자바스크립트는 객체 기반형 프로그래밍 언어**이다.

**`객체`** 는 0개 이상의 **프로퍼티와 메서드로 구성된 집합** 이며

**`프로퍼티`** 는 **객체의 상태를 나타내는 값** 이라 하고 **키와 값**으로 구성된다.

### 객체 리터럴에 의한 객체 생성

**c++**이나 **자바** 같은 `클래스 기반 객체 지향 언어`는 **클래스를 사전에 정의**하고 **new 연산자**와 함께 생성자를 호출해서 **인스턴스를 생성**하는 방식으로 객체를 생성하지만,

**자바스크립트**는 `프로토타입 기반 객체지향 언어`이기때문에 **다양한 객체 생성 방법을 지원**한다.

- 객체 리터럴
  **자바스크립트**에서는 **일반적으로는 객체 리터럴**을 사용해서 객체를 생성하게된다.
  객체 리터럴은 **중괄호({...}) 사용해 객체 생성**을 한다.

  ```jsx
  // 객체 리터럴을 사용해서 객체 생성
  let person = {
    name: "jaehyun",
    sayHello: function () {
      console.log(`hello my name is ${this.name}.`);
    },
  };
  // 중괄호 안에 프로퍼티를 정의하지않으면 빈객체가 생성된다.
  ```

  이러한 방식은 **객체 리터럴에 프로퍼티를 포함**시켜 **객체를 생성함과 동시에 프로퍼티를 만들수있다**
  또 생성한 이후에 **프로퍼티를 동적으로 추가**도 할수있다.

  ### ES6 이후 추가된 객체 리터럴 확장기능 추가

  - 프로퍼티 값은 **변수에 할당된 값**을 넣을수있다.
  - 프로퍼티 값에 변수를 사용하는경우 **키와 이름이 동일**하다면 **프로퍼티 키를 생략할수있다**. 이때 키이름은 **변수 이름으로 자동 생성**된다.
  - **계산된 프로퍼티 이름**

    - 문자열, 문자열로 타입변환할수있는 값으로 평가되는 표현식을 사용해 키를 **동적으로 생성할수있다.**

    ```jsx
    const prefix = "prop";
    let i = 0;

    // 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 키를 동적으로 생성
    const obj = {
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
    };
    ```

- object 생성자 함수
- 생성자 함수
- object.create 메서드
- 클래스 (ES6)

### 프로퍼티

- `프로퍼티 키` : 빈 문자열을 포함한 **모든 문자열 , 심벌 값**
  - **프로퍼티 값**에 접근할수있는 **식별자 역할**
  - **식별자 네이밍 규칙에 준수**하다면 **따옴표를 생략 가능**하다
  - **식별자 네이밍 규칙에 따르지않는 이름**에는 반드시 **따옴표 를 사용**해야한다.
  - 이미존재하는 프로퍼티 키를 **중복선언하면** 나중에 선언된 값이 **덮어쓰게된다**.
- `프로퍼티 값` : 자바스크립트에서 사용할수있는 **모든 값**

  - 이미 **존재**하는 프로퍼티에 값을 할당하면 값이 **갱신**된다.
  - 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되고 추가된다.

  ```jsx
  let person = { name: "jaehyun" };

  person.age = 20;

  console.log(person); // {name:"jaehyun", age:20}
  ```

### 프로퍼티 접근

프로퍼티에 접근하는 방법은 **2가지**가 있다.

프로퍼티 키가 **식별자 네이밍 규칙**을 준수하는 이름이라면 **2가지 다 사용가능**하다.

그게아니라면 반드시 **대괄호 표기법을 사용**해야한다.

- `마침표 표기법`
- `대괄호 표기법`
  - **프로퍼티 키** 는 **따옴표로 감싼 문자열** 이여야 한다.
  - 아니면 **레퍼랜스 에러**가 발생한다.

```jsx
let person = {
  name: "jaehyun",
};

console.log(person.name);
//마침표 표기법
console.log(person["name"]);
//대괄호 표기법
console.log(person.age);
//존재하지 않은 프로퍼티에 접근하면 undefined 을 반환한다.
```

- `프로퍼티 삭제`
  - 존재하는 프로퍼티를 delete 연산자 사용해서 객체의 프로퍼티를 삭제 할수있다.
  - `delete 객체.프로퍼티키 ;`

### 메서드

**프로퍼티 값이 함수일경우** 일반함수와 구별하기위해 **메서드** 라 부른다.

즉 **메서드**는 **객체에 묶여있는 함수**를 의미한다.
